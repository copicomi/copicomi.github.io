<!DOCTYPE html>
<html lang="en-us"
  dir="ltr">

<head>
  <meta charset="utf-8">
<meta name="viewport" content="width=device-width">








    






<link rel="icon" type="image/ico" href="https://copicomi.github.io/favicon.ico">
<link rel="icon" type="image/png" sizes="16x16" href="https://copicomi.github.io/favicon-16x16.png">
<link rel="icon" type="image/png" sizes="32x32" href="https://copicomi.github.io/favicon-32x32.png">
<link rel="icon" type="image/png" sizes="192x192" href="https://copicomi.github.io/android-chrome-192x192.png">
<link rel="apple-touch-icon" sizes="180x180" href="https://copicomi.github.io/apple-touch-icon.png">

<meta name="description" content=""/>



<title>
    
    重读 xv6（IV） | Anri’s blog
    
</title>

<link rel="canonical" href="https://copicomi.github.io/posts/%E9%87%8D%E8%AF%BB-xv6/iv/"/>

<meta property="og:url" content="https://copicomi.github.io/posts/%E9%87%8D%E8%AF%BB-xv6/iv/">
  <meta property="og:site_name" content="Anri’s blog">
  <meta property="og:title" content="重读 xv6（IV）">
  <meta property="og:description" content="xv6 Trap 与系统调用">
  <meta property="og:locale" content="en_us">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2025-10-29T00:00:00+00:00">
    <meta property="article:modified_time" content="2025-10-29T00:00:00+00:00">
    <meta property="article:tag" content="C">
    <meta property="article:tag" content="Xv6">
    <meta property="article:tag" content="Os">












<link rel="stylesheet" href="/assets/combined.min.e7f6afb3c50c5ab501fcb9f8df55d1e16a605f545d4b7ccca3a4a80f66486f8b.css" media="all">















    




</head>







<body class="dark">

  <div class="content">
    <header>
      

<div class="header">

    

    <h1 class="header-title">
        <a href="https://copicomi.github.io/">Anri’s blog</a>
    </h1>

    <div class="header-menu">
        

        
        

        <p
            class="small ">
            <a href="/" >
                /home
            </a>
        </p>
        

        <p
            class="small ">
            <a href="/posts" >
                /posts
            </a>
        </p>
        

        <p
            class="small ">
            <a href="/categories" >
                /categories
            </a>
        </p>
        

        <p
            class="small ">
            <a href="/tags" >
                /tags
            </a>
        </p>
        
        
    </div>

    

</div>

    </header>

    <main class="main">
      




<div class="breadcrumbs"><a href="/">Home</a><span class="breadcrumbs-separator">/</span><a href="/posts/">Posts</a><span class="breadcrumbs-separator">/</span>
        <a href="/posts/%E9%87%8D%E8%AF%BB-xv6/iv/">重读 xv6（IV）</a></div>


<div >
  <article>
    <header class="single-intro-container">
        
        <h1 class="single-title">重读 xv6（IV）</h1>
        <p class="single-summary">xv6 Trap 与系统调用</p>
        
        <div class="single-subsummary">
          
          <div>
            
            <p class="single-date">
              <time datetime="2025-10-29T00:00:00&#43;00:00">October 29, 2025</time>
            </p>
          </div>
        </div>
        
    </header>
    
    <div class="single-content">
      <h1 class="heading" id="五">
  五
  <a class="anchor" href="#%e4%ba%94">#</a>
</h1>
<p>现在我们讨论 Trap 机制，用于三个方面：</p>
<ol>
<li>系统调用</li>
<li>异常中断</li>
<li>设备中断</li>
</ol>
<h2 class="heading" id="透明操作">
  透明操作
  <a class="anchor" href="#%e9%80%8f%e6%98%8e%e6%93%8d%e4%bd%9c">#</a>
</h2>
<p>Trap 是由 riscv 硬件提供的服务，触发时的工作流程：</p>
<ol>
<li>保存当前的程序计数器 <code>%pc</code> 到 <code>%sepc</code></li>
<li>记录当前的权限模式</li>
<li>设置 <code>%scause</code>，记录 Trap 原因</li>
<li>进入 <em><strong>kernel mode</strong></em></li>
<li>根据预先设置好的中断向量 <code>%stvec</code>，跳转到中断服务程序</li>
</ol>
<p>中断结束时，根据 <code>%sepc</code> 回到原先的程序位置<br>
而在中断服务期间，我们可以选择 <em>关中断</em>，暂时屏蔽其他信号源</p>
<blockquote>
<p>硬件只做最少量的工作，以保证内核软件的灵活性</p>
</blockquote>
<h2 class="heading" id="中转代码">
  中转代码
  <a class="anchor" href="#%e4%b8%ad%e8%bd%ac%e4%bb%a3%e7%a0%81">#</a>
</h2>
<p><strong>源码文件：<code>trampoline.S</code></strong></p>
<p>在 <em><strong>III</strong></em> 中，我们提到过，无论是内核还是用户，都会将虚拟空间的顶部映射为 <code>TRAMPOLINE</code>，实际就是用于 trap 的代码</p>
<p>而在 <code>TRAMPOLINE</code> 下面则是记录寄存器信息的 <code>trapframe</code></p>
<p>从用户空间触发 <code>trap</code> 时，硬件会将中断向量指向 <code>trampoline.S/uservec</code>，运行内核软件的处理程序</p>
<p>而 <code>uservec</code> 会将 用户态的上下文保存到 <code>trapframe</code> 中，同时从 <code>trapframe</code> 中读取内核所需的信息</p>
<blockquote>
<p>需要保存的信息是 32 个寄存器的内容，但是我们需要占用至少一个寄存器来运行程序，怎么办呢？</p>
<p>解决方案是提供一个 <code>%sscratch</code> 寄存器，用于临时保存 <code>%a0</code> 的内容，而我们则征用 <code>%a0</code> 存储 <code>trapframe</code> 的地址</p>
</blockquote>
<blockquote>
<p>需要读取的信息：</p>
<ol>
<li><code>trap.c/usertrap()</code> 的地址</li>
<li><code>kernel stack</code> 的地址</li>
<li><code>kernel pagetable</code> 的地址</li>
<li>内核的 <code>hartid</code></li>
</ol>
</blockquote>
<p>最后，<code>uservec</code> 会修改 <code>%satp</code>，转为使用内核页表，然后 <code>jmp</code> 到 <code>usertrap</code>，正式进入处理逻辑</p>
<blockquote>
<p>这里我们修改了页表，达成了与 <em><strong>III</strong></em> 中，<code>kvmhartinit</code> 无缝启用页表机制相同的效果，这是因为切换前后，<code>trampoline</code> 的地址映射没有改变，因此程序计数器不受影响，程序流不会改变</p>
<p>但是需要注意 <code>trapframe</code> 并不是这样，每个程序的 <code>trapframe</code> 具有独立的物理地址，在 <code>proc.c/allocproc</code> 中通过 <code>kalloc</code> 获取，在 <code>proc_pagetable</code> 中初始化地址映射</p>
</blockquote>
<p>而在 <code>userret</code> 中，我们复原 <code>trapframe</code> 中的用户数据，并重定向 <code>ret</code> 到原位置即可</p>
<h2 class="heading" id="trap-处理">
  Trap 处理
  <a class="anchor" href="#trap-%e5%a4%84%e7%90%86">#</a>
</h2>
<p><em><strong>源码文件：<code>trap.c</code></strong></em></p>
<p>安排好寄存器这些繁杂的细节之后，我们才进入正题，检查中断类型，并进行对应处理</p>
<p><code>usertrap</code> 的流程其实很简单：</p>
<ol>
<li>将中断向量重定向为 <code>kerneltrap</code></li>
<li>检查 <code>%scause</code>，判断中断类型</li>
<li><em><strong>do something</strong></em></li>
<li>调用 <code>usertrapret</code>，返回到用户空间</li>
</ol>
<blockquote>
<p>这里引出了一个问题：<code>user</code> 与 <code>kernel</code> 的中断处理是不同的，为什么呢？</p>
</blockquote>
<p>这里的 <em><strong>do something</strong></em>，就是处理的具体内容：时钟中断就让出 CPU，系统调用就去调用，设备中断就动设备，等等</p>
<blockquote>
<p>此处是 <code>trap</code> 机制中最可扩展的部分，开发者可以实现自己想要的机制</p>
<p>拿 <em><strong>copy-on-write</strong></em> 举例，我们将 复制页 设置为只读，写入时引发 <em><strong>page fault</strong></em>，此时硬件会触发异常中断，陷入到 <code>usertrap</code> ，我们检查 <code>%scause</code> 便可得知异常类型，再动态分配页面即可实现该机制</p>
</blockquote>
<p>而 <code>usertrapret</code> 调整好权限与 <code>trapframe</code>，重定向返回地址 <code>sepc</code> ，再调用 <code>userret</code> 即可</p>
<blockquote>
<p>读源码可以发现，这一系列流程都是通过函数调用作为连接的，然而最后 <code>userret</code> 却直接回到了用户空间，让人不禁想问，这么做不会导致栈溢出吗，为什么没有释放栈上的调用信息呢？</p>
<p>担心是多余的，<code>trapframe</code> 中我们会单独保存 <code>kernel stack</code> 的起始地址，每次从 <code>usertrap</code> 进入时，都会重置 <code>%sp</code> 指向内核栈底，之前的调用信息也就成为了垃圾信息，而用户栈被保存在 <code>trapframe-&gt;sp</code> 中</p>
</blockquote>
<h2 class="heading" id="内核中断">
  内核中断
  <a class="anchor" href="#%e5%86%85%e6%a0%b8%e4%b8%ad%e6%96%ad">#</a>
</h2>
<p><em><strong>源码文件：<code>kernelvec.S</code></strong></em></p>
<p>即便是内核程序，也有可能被设备与异常所中断，因此要另起一套内核 <code>trap</code> 的逻辑</p>
<p>不过 <code>kernelvec</code>、<code>kerneltrap</code> 的行为与用户 <code>trap</code> 相差不大，区别在于 <code>kernel</code> 会将寄存器内容保护在 <code>kernel stack</code> 上，而不是 <code>trapframe</code></p>
<blockquote>
<p>用户 <code>trap</code> 只会发生一次，并且明确属于某个 <code>proc</code>，但内核 <code>trap</code> 可能会嵌套进行，所以用栈保护寄存器</p>
</blockquote>
<h2 class="heading" id="重新启动">
  重新启动
  <a class="anchor" href="#%e9%87%8d%e6%96%b0%e5%90%af%e5%8a%a8">#</a>
</h2>
<p>现在我们看一下 <code>main.c</code> 中对 <code>trap</code> 做了怎样的初始化</p>
<ul>
<li><code>trapinit</code>：初始化 <code>time lock</code>，用来管理时钟中断</li>
<li><code>trapinithart</code>：将 <code>%stvec</code> 设置为 <code>kernelvec</code>，因为起初代码处于内核态</li>
</ul>
<p>除此之外没有其他动作，<code>trap</code> 的初始化就是这样</p>
<p>再检查 <em><strong>II</strong></em> 中提到的 <code>forkret</code>，只是调用 <code>usertrapret</code> 进入用户态</p>
<p>这里 <code>usertrapret</code> 是混沌状态下的操作，我们看看它做了什么：</p>
<ul>
<li>将中断向量设置为 <code>uservec</code></li>
<li>将内核状态保存到 <code>trapframe</code></li>
<li>从 <code>trapframe</code> 中读取寄存器内容</li>
<li>重定向到用户线程</li>
</ul>
<p>这引出一个问题，如何保证从 <code>trapframe</code> 中读取的寄存器内容具备合理性（reasonable）？</p>
<p>溯源可以发现：</p>
<ol>
<li>可用寄存器的内容在初始化时无意义，因此是垃圾也无所谓</li>
<li>内核状态是从 CPU 中直接读取的</li>
<li><code>%sp</code>，<code>%epc</code>的内容在 <code>exec</code> 中已经设置好</li>
<li><code>pagetable</code> 在 <code>allocproc</code> 中完成映射</li>
</ol>
<p>因此这里 <code>forkret</code> 直接调用 <code>usertrapret</code> 是没问题的</p>
<h2 class="heading" id="系统调用">
  系统调用
  <a class="anchor" href="#%e7%b3%bb%e7%bb%9f%e8%b0%83%e7%94%a8">#</a>
</h2>
<p><em><strong>源码文件：<code>syscall.c</code></strong></em></p>
<p>基于 Trap 机制，我们可以从系统调用陷入到内核态，运行 kernel 代码</p>
<p>整个 <code>syscall</code> 的实现逻辑很简单：</p>
<ol>
<li>约定参数在 <code>trapframe</code> 中的位置</li>
<li>预定义调用表</li>
<li>运行 <code>syscall function</code>，从 <code>trapframe</code> 读取调用号与参数</li>
<li>将返回值覆盖到 <code>trapframe</code> 中</li>
<li>将 <code>%pc</code> 指针向后移动一位，表示完成 <code>syscall</code></li>
<li>从 <code>trap</code> 中返回用户空间，用 <code>trapframe</code> 覆盖寄存器</li>
</ol>
<p>用户视角下，<code>%pc</code>后移一条指令，返回值放在约定的寄存器<code>%a0</code>，就像一瞬间完成了系统调用一般，从而完成了系统调用的<strong>透明化</strong></p>
<p>kernel 可能与用户内存进行读写交互，但二者的页表并不一致，因此我们需要编写在 kernel 与 user 间进行内存交互的辅助函数，在 <em><strong>xv6</strong></em> 中则是 <code>vm.c</code> 中的 <code>copyin/copyout</code> 逻辑</p>
<blockquote>
<p>到这里，我们发现了矛盾，kernel 与 user 的页表是隔离的，才只能通过 <code>trapframe</code> 这样的中介进行通信，如果我们在彼此中插入对方的代码映射呢？</p>
<p>在 user 中插入 kernel 的映射，就不需要大费周章地更换页表，直接换权限，运行kernel代码就好了<br>
在 kernel 中插入 user 的映射，就不需要两头跑 copy 信息，直接读出 user 的内存即可</p>
<p>这种设计明显可行，因为虚拟内存是无限的，我们稍微加一点限制，将 user 和 kernel 的映射强制分区，便可以在同一张页表里映射两态的空间</p>
</blockquote>
<hr>
<p>本节，我们回答了以下问题：</p>
<ol>
<li>硬件如何响应中断信号</li>
<li>中断服务如何切换线程的上下文</li>
<li>连接中断源与中断处理的胶水代码是怎样的</li>
<li><code>trampoline</code> 与 <code>trapframe</code> 映射的设计目的是什么</li>
<li>调用 <code>syscall</code> 时，xv6 内部发生了什么</li>
<li><code>trap</code> 机制如何作用于其他模块</li>
</ol>

    </div>
  </article>

  

  

  
  

<div class="single-pagination">
    <hr />

    <div class="flexnowrap">

        <div class="single-pagination-prev">
            
            <div class="single-pagination-container-prev">
                <div class="single-pagination-text">←</div>
                <div class="single-pagination-text">
                    <a href="/posts/%E9%87%8D%E8%AF%BB-xv6/iii/">
                        重读 xv6（III）
                    </a>
                </div>
            </div>
            
        </div>

        <div class="single-pagination-next">
            
            <div class="single-pagination-container-next">
                <div class="single-pagination-text">
                    <a href="/posts/%E9%87%8D%E8%AF%BB-xv6/v/">
                        重读 xv6（V）
                    </a>
                </div>
                <div class="single-pagination-text">→</div>
            </div>
            
        </div>

    </div>

    <hr />
</div>



  

  

  
  <div class="back-to-top">
    <a href="#top">
      back to top
    </a>
  </div>
  

</div>


    </main>
  </div>

  
  





    




  <footer>
    

    
    





    




    
    <p>Powered by
        <a href="https://gohugo.io/">Hugo</a>
        and
        <a href="https://github.com/tomfran/typo">tomfran/typo</a>
    </p>
    
    
    


  </footer>

  
</body>

<script src="/js/theme-switch.js"></script>
<script defer src="/js/copy-code.js"></script>
</html>
