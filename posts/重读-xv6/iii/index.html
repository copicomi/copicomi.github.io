<!DOCTYPE html>
<html lang="en-us"
  dir="ltr">

<head>
  <meta charset="utf-8">
<meta name="viewport" content="width=device-width">








    






<link rel="icon" type="image/ico" href="https://copicomi.github.io/favicon.ico">
<link rel="icon" type="image/png" sizes="16x16" href="https://copicomi.github.io/favicon-16x16.png">
<link rel="icon" type="image/png" sizes="32x32" href="https://copicomi.github.io/favicon-32x32.png">
<link rel="icon" type="image/png" sizes="192x192" href="https://copicomi.github.io/android-chrome-192x192.png">
<link rel="apple-touch-icon" sizes="180x180" href="https://copicomi.github.io/apple-touch-icon.png">

<meta name="description" content=""/>



<title>
    
    重读 xv6（III） | Anri’s blog
    
</title>

<link rel="canonical" href="https://copicomi.github.io/posts/%E9%87%8D%E8%AF%BB-xv6/iii/"/>

<meta property="og:url" content="https://copicomi.github.io/posts/%E9%87%8D%E8%AF%BB-xv6/iii/">
  <meta property="og:site_name" content="Anri’s blog">
  <meta property="og:title" content="重读 xv6（III）">
  <meta property="og:description" content="xv6 虚拟内存">
  <meta property="og:locale" content="en_us">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2025-10-28T00:00:00+00:00">
    <meta property="article:modified_time" content="2025-10-28T00:00:00+00:00">
    <meta property="article:tag" content="C">
    <meta property="article:tag" content="Xv6">
    <meta property="article:tag" content="Os">












<link rel="stylesheet" href="/assets/combined.min.e7f6afb3c50c5ab501fcb9f8df55d1e16a605f545d4b7ccca3a4a80f66486f8b.css" media="all">















    




</head>







<body class="dark">

  <div class="content">
    <header>
      

<div class="header">

    

    <h1 class="header-title">
        <a href="https://copicomi.github.io/">Anri’s blog</a>
    </h1>

    <div class="header-menu">
        

        
        

        <p
            class="small ">
            <a href="/" >
                /home
            </a>
        </p>
        

        <p
            class="small ">
            <a href="/posts" >
                /posts
            </a>
        </p>
        

        <p
            class="small ">
            <a href="/categories" >
                /categories
            </a>
        </p>
        

        <p
            class="small ">
            <a href="/tags" >
                /tags
            </a>
        </p>
        
        
    </div>

    

</div>

    </header>

    <main class="main">
      




<div class="breadcrumbs"><a href="/">Home</a><span class="breadcrumbs-separator">/</span><a href="/posts/">Posts</a><span class="breadcrumbs-separator">/</span>
        <a href="/posts/%E9%87%8D%E8%AF%BB-xv6/iii/">重读 xv6（III）</a></div>


<div >
  <article>
    <header class="single-intro-container">
        
        <h1 class="single-title">重读 xv6（III）</h1>
        <p class="single-summary">xv6 虚拟内存</p>
        
        <div class="single-subsummary">
          
          <div>
            
            <p class="single-date">
              <time datetime="2025-10-28T00:00:00&#43;00:00">October 28, 2025</time>
            </p>
          </div>
        </div>
        
    </header>
    
    <div class="single-content">
      <h1 class="heading" id="四">
  四
  <a class="anchor" href="#%e5%9b%9b">#</a>
</h1>
<p>我们希望对用户隐藏底层物理空间，并提供无限大的虚拟空间假象，这就是虚拟内存的想法</p>
<h2 class="heading" id="物理内存">
  物理内存
  <a class="anchor" href="#%e7%89%a9%e7%90%86%e5%86%85%e5%ad%98">#</a>
</h2>
<p><em><strong>源码文件：<code>kalloc.c</code></strong></em></p>
<p>xv6 采用链表组织内存块，初始化时，将可用内存按固定分块加入链表</p>
<p>运行时通过 <code>kalloc</code>、<code>kfree</code> 获取其物理地址，再绑定到 <code>pagetable</code> 映射，便可以被用户进程使用了</p>
<blockquote>
<p>另起一个超大内存块的链表，进行分类讨论，就可以实现扩展的 superpage 特性</p>
</blockquote>
<h2 class="heading" id="空间结构">
  空间结构
  <a class="anchor" href="#%e7%a9%ba%e9%97%b4%e7%bb%93%e6%9e%84">#</a>
</h2>
<p><em><strong>源码文件：<code>memlayout.h</code></strong></em></p>
<p>解决物理地址的映射问题后，我们便只需要关注虚拟内存了，这个空间是如何组织的呢？</p>
<p>虚拟空间由以下部分组成：</p>
<ol>
<li>用户程序与数据</li>
<li>用户栈，固定大小</li>
<li>堆，用于动态分配空间</li>
<li><code>TRAMPOLINE</code>、<code>Trapframe</code>，用于 <code>Trap</code> 到内核态</li>
</ol>
<blockquote>
<p>用户栈是由 <code>exec</code> 负责分配的，此处按下不表</p>
</blockquote>
<p>











<figure class="">

    <div class="img-container" style="--w: 1280; --h: 837;">
        <img loading="lazy" alt="用户视角下的空间" src="/posts/%E9%87%8D%E8%AF%BB-xv6/iii/assets/user-view.png" width="1280" height="837">
    </div>

    
    <div class="caption-container">
        <figcaption> 用户视角下的空间 </figcaption>
    </div>
    
</figure>
</p>
<h2 class="heading" id="地址转换">
  地址转换
  <a class="anchor" href="#%e5%9c%b0%e5%9d%80%e8%bd%ac%e6%8d%a2">#</a>
</h2>
<p><em><strong>源码文件：<code>vm.c</code></strong></em></p>
<p>这种虚拟地址（virture address）的转换，必须有硬件做支持，事实上我们有一个专门用来记录页表地址的寄存器，这样用户引用 va 时，硬件可以自动完成地址翻译</p>
<p>因此我们只需要关心如何安排页表映射即可</p>
<p>xv6 以 <code>mappage</code> 与 <code>walk</code> 作为该逻辑的核心</p>
<ol>
<li><code>walk</code> 按偏移量逐层查找多级页表</li>
<li><code>mappage</code> 将内存段逐页加入页表映射</li>
</ol>
<p>xv6 的页表设计：</p>
<ol>
<li>三层</li>
<li>存储 物理地址 与 读写权限位</li>
<li><code>satp</code> 寄存器记录页表地址</li>
</ol>
<blockquote>
<p>权限位的设计，提供了极大的扩展性，我们可以添加自定义的标记以支持新功能<br>
例如可以增加 <code>PTE_S</code> 权限位，只遍历前两层，用于指代 <code>superPage</code></p>
</blockquote>
<h2 class="heading" id="应用层">
  应用层
  <a class="anchor" href="#%e5%ba%94%e7%94%a8%e5%b1%82">#</a>
</h2>
<p>以 <code>kalloc</code> 与 <code>walk-mappage</code> 逻辑为基础设施，我们便可以实现常用的辅助函数：</p>
<ol>
<li><code>uvmalloc</code>/<code>uvmdealloc</code> 申请与释放堆空间</li>
<li><code>uvmcopy</code> 复制 <code>fork</code> 进程的内存空间</li>
<li><code>uvmmap</code>/<code>uvmunmap</code> 插入或移除 page 映射</li>
<li><code>uvmcreate</code> 申请用户页表</li>
</ol>
<p>现在我们就理解，II 中创建进程的 <code>allocproc</code> 在做什么了</p>
<ol>
<li>申请页表</li>
<li>插入 <code>trap</code> 与 <code>kernel stack</code> 映射</li>
</ol>
<p>申请堆空间，<code>kalloc</code> 后更新映射与 size 计数即可</p>
<p>而 <code>fork</code> 就是复制页表后，逐页将其内容 copy 到新进程</p>
<blockquote>
<p><code>fork</code> 时，我们当然可以现在一股脑把物理地址的内容也复制过去，但也有更好的做法</p>
<p>由于 <code>va</code> 机制是基于映射的，可以在映射上面做手脚，让两个不同的 <code>va</code> 指向同一块物理地址，真正写入时再进行区分，这就是 <em><strong>copy-on-write</strong></em> 的思想</p>
</blockquote>
<h2 class="heading" id="内核特权">
  内核特权
  <a class="anchor" href="#%e5%86%85%e6%a0%b8%e7%89%b9%e6%9d%83">#</a>
</h2>
<p>虚拟内存是针对用户而言的，那么 kernel 视角下的内存是什么样的呢？</p>
<p>按理说 kernel 拥有更高权限，应该能直接操作物理地址，但只有 <em><strong>machine mode</strong></em> 才能做到这一点</p>
<p><em><strong>kernel mode</strong></em> 仍旧使用 页表，只不过我们将物理地址进行直接映射，把 x 映射到了 x</p>
<p>因此 kernel 可以直接访问设备、内核程序等内容，无缝运行内核代码</p>
<blockquote>
<p>内核页表的映射，会将 <code>PTE_U</code> 置为禁止用户访问，防止用户通过漏洞恶意访问内核地址</p>
<p>举个例子，一般我们会将页表存入 TLB 缓存，方便读取，如果切换回用户态时，忘记清理 TLB 缓存，那么用户就能通过过期的kernel 映射，直接访问到内核的真实物理地址</p>
</blockquote>
<p>此外，kernel 为 <code>trapframe</code> 与 <code>kstack</code> 提供了额外的映射，便于共享内存</p>
<blockquote>
<p>这两个额外的 va 都放在 <code>MAXVA</code> 顶部，其中 trap 映射是为了所有进程能够共享同一段只读程序，kstack映射则是为了在中间插入虚拟的<code>guardPage</code>，一旦访问到 guard 就会引发异常报错</p>
<p>这里的一个技巧是<strong>假映射</strong>，通过让用户访问无效映射，引发 page fault</p>
</blockquote>
<p>











<figure class="">

    <div class="img-container" style="--w: 901; --h: 974;">
        <img loading="lazy" alt="内核视角下的空间" src="/posts/%E9%87%8D%E8%AF%BB-xv6/iii/assets/kernel-view.png" width="901" height="974">
    </div>

    
    <div class="caption-container">
        <figcaption> 内核视角下的空间 </figcaption>
    </div>
    
</figure>
</p>
<h2 class="heading" id="重新启动">
  重新启动
  <a class="anchor" href="#%e9%87%8d%e6%96%b0%e5%90%af%e5%8a%a8">#</a>
</h2>
<p>检查完整个虚拟内存的设计后，我们回头看 <code>main.c/kvminit</code> 等初始化函数到底做了什么</p>
<ul>
<li><code>kinit</code> 将所有空闲的物理内存块都塞入 <code>kalloc</code> 链表中，用于分配堆</li>
<li><code>kvminit</code> 申请 kernel 页表，加入直接映射，分配内核栈映射，用于 kernel 运行</li>
<li><code>kvmhartinit</code> 将页表寄存器 <code>%satp</code> 替换为 <code>kernel pagetable</code>，启动<strong>地址转换</strong>功能</li>
</ul>
<blockquote>
<p>由于 kernel 采用的是直接映射，所以启动地址转换后，程序计数器的内容没有改变，程序流并不受影响，完成无缝切换</p>
</blockquote>
<p>事实上，<em><strong>kernel mode</strong></em> 比 <em><strong>machine mode</strong></em> 的内容更加丰富，增加的映射是针对系统的优化</p>
<h2 class="heading" id="第一发现人">
  第一发现人
  <a class="anchor" href="#%e7%ac%ac%e4%b8%80%e5%8f%91%e7%8e%b0%e4%ba%ba">#</a>
</h2>
<p><em><strong>源码文件：<code>exec.c</code></strong></em></p>
<p>我们已经谈论过如何请求新的进程资源、复制一个现成的进程，可还是不明白，用户程序是怎样被加载到进程中的？</p>
<p>这就是 <code>exec</code> 的工作，它是一切的开端，我们调用 <code>exec init</code> 才有了第一个进程的出生</p>
<p><code>exec</code> 的流程：</p>
<ol>
<li>读取程序文件</li>
<li>载入 <code>elf header</code>，检查文件格式</li>
<li>申请新页表，将 <code>program</code> 内容载入到内存中</li>
<li>申请<strong>用户栈</strong>，将 <code>args[]</code> 压入栈，设置 <code>guard page</code> 的 <code>PTE_U</code> 为不可读</li>
<li>修改栈指针 <code>%sp</code> 与返回地址 <code>%epc</code>，重定向程序流</li>
<li>覆盖、释放原进程的页表空间</li>
</ol>
<p><code>ret</code> 后，程序将从 <code>elf</code> 文件定义的起点开始执行，完成程序镜像的替换</p>
<blockquote>
<p><code>exec</code> 修改了程序流与内存空间，但是并不影响 pid 这些进程状态</p>
</blockquote>
<p>至此我们理解了一个用户任务是如何载入 <em><strong>xv6</strong></em> ，并参与 CPU 调度的</p>
<hr>
<p>这一节我们回答了以下问题：</p>
<ol>
<li>各个视角下的虚拟内存是怎么组织的？</li>
<li>xv6 如何动态分配内存？</li>
<li>xv6 如何管理页表资源？</li>
<li><strong>地址转换的透明化是由硬件完成的</strong></li>
<li>栈、堆、代码，这些资源分别是在何时映射到 xv6 进程中的？</li>
<li><code>vm.c</code> 中的接口如何被上层所使用？</li>
<li>一块物理内存，从申请到释放，它的生命周期是怎样的？</li>
</ol>

    </div>
  </article>

  

  

  
  

<div class="single-pagination">
    <hr />

    <div class="flexnowrap">

        <div class="single-pagination-prev">
            
            <div class="single-pagination-container-prev">
                <div class="single-pagination-text">←</div>
                <div class="single-pagination-text">
                    <a href="/posts/%E9%87%8D%E8%AF%BB-xv6/ii/">
                        重读 xv6（II）
                    </a>
                </div>
            </div>
            
        </div>

        <div class="single-pagination-next">
            
            <div class="single-pagination-container-next">
                <div class="single-pagination-text">
                    <a href="/posts/%E9%87%8D%E8%AF%BB-xv6/iv/">
                        重读 xv6（IV）
                    </a>
                </div>
                <div class="single-pagination-text">→</div>
            </div>
            
        </div>

    </div>

    <hr />
</div>



  

  

  
  <div class="back-to-top">
    <a href="#top">
      back to top
    </a>
  </div>
  

</div>


    </main>
  </div>

  
  





    




  <footer>
    

    
    





    




    
    <p>Powered by
        <a href="https://gohugo.io/">Hugo</a>
        and
        <a href="https://github.com/tomfran/typo">tomfran/typo</a>
    </p>
    
    
    


  </footer>

  
</body>

<script src="/js/theme-switch.js"></script>
<script defer src="/js/copy-code.js"></script>
</html>
